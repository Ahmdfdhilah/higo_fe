"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/page",{

/***/ "(app-pages-browser)/./src/services/customer.ts":
/*!**********************************!*\
  !*** ./src/services/customer.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerService: function() { return /* binding */ CustomerService; },\n/* harmony export */   customerService: function() { return /* binding */ customerService; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./src/services/base.ts\");\n\n// Customer API Service\nclass CustomerService extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseApiService {\n    // Get all customers with pagination and filters\n    async getAllCustomers(pagination, filters) {\n        const params = {\n            ...pagination,\n            ...filters\n        };\n        return this.get(this.endpoint, params);\n    }\n    // Get customer by ID\n    async getCustomerById(id) {\n        return this.get(\"\".concat(this.endpoint, \"/\").concat(id));\n    }\n    // Create new customer\n    async createCustomer(customerData) {\n        return this.post(this.endpoint, customerData);\n    }\n    // Update customer\n    async updateCustomer(id, updateData) {\n        return this.put(\"\".concat(this.endpoint, \"/\").concat(id), updateData);\n    }\n    // Delete customer\n    async deleteCustomer(id) {\n        return this.delete(\"\".concat(this.endpoint, \"/\").concat(id));\n    }\n    // Get customer summary for dashboard\n    async getCustomerSummary() {\n        return this.get(\"\".concat(this.endpoint, \"/summary\"));\n    }\n    // CSV Import methods\n    async importCustomersFromCSV(file, options) {\n        const formData = new FormData();\n        formData.append(\"csvFile\", file);\n        if (options === null || options === void 0 ? void 0 : options.skipValidation) {\n            formData.append(\"skipValidation\", \"true\");\n        }\n        if ((options === null || options === void 0 ? void 0 : options.continueOnError) !== undefined) {\n            formData.append(\"continueOnError\", options.continueOnError.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.batchSize) {\n            formData.append(\"batchSize\", options.batchSize.toString());\n        }\n        try {\n            const response = await this.api.post(\"\".concat(this.endpoint, \"/import/csv\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                timeout: 600000\n            });\n            return response.data;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Get import status\n    async getImportStatus(importId) {\n        return this.get(\"\".concat(this.endpoint, \"/import/status/\").concat(importId));\n    }\n    // Cancel import\n    async cancelImport(importId) {\n        return this.post(\"\".concat(this.endpoint, \"/import/cancel/\").concat(importId));\n    }\n    // Get active imports\n    async getActiveImports() {\n        return this.get(\"\".concat(this.endpoint, \"/import/active\"));\n    }\n    constructor(...args){\n        super(...args);\n        this.endpoint = \"/customers\";\n    }\n}\n// Export singleton instance\nconst customerService = new CustomerService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jdXN0b21lci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEY7QUFxSDFGLHVCQUF1QjtBQUNoQixNQUFNQyx3QkFBd0JELGlEQUFjQTtJQUdqRCxnREFBZ0Q7SUFDaEQsTUFBTUUsZ0JBQ0pDLFVBQTZCLEVBQzdCQyxPQUF5QixFQUNtRDtRQUM1RSxNQUFNQyxTQUFTO1lBQ2IsR0FBR0YsVUFBVTtZQUNiLEdBQUdDLE9BQU87UUFDWjtRQUNBLE9BQU8sSUFBSSxDQUFDRSxHQUFHLENBQXVELElBQUksQ0FBQ0MsUUFBUSxFQUFFRjtJQUN2RjtJQUVBLHFCQUFxQjtJQUNyQixNQUFNRyxnQkFBZ0JDLEVBQVUsRUFBb0Q7UUFDbEYsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBNkIsR0FBb0JHLE9BQWpCLElBQUksQ0FBQ0YsUUFBUSxFQUFDLEtBQU0sT0FBSEU7SUFDbEU7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUMsZUFBZUMsWUFBK0IsRUFBNkM7UUFDL0YsT0FBTyxJQUFJLENBQUNDLElBQUksQ0FBc0IsSUFBSSxDQUFDTCxRQUFRLEVBQUVJO0lBQ3ZEO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1FLGVBQWVKLEVBQVUsRUFBRUssVUFBNkIsRUFBb0Q7UUFDaEgsT0FBTyxJQUFJLENBQUNDLEdBQUcsQ0FBNkIsR0FBb0JOLE9BQWpCLElBQUksQ0FBQ0YsUUFBUSxFQUFDLEtBQU0sT0FBSEUsS0FBTUs7SUFDeEU7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTUUsZUFBZVAsRUFBVSxFQUFvRDtRQUNqRixPQUFPLElBQUksQ0FBQ1EsTUFBTSxDQUE2QixHQUFvQlIsT0FBakIsSUFBSSxDQUFDRixRQUFRLEVBQUMsS0FBTSxPQUFIRTtJQUNyRTtJQUVBLHFDQUFxQztJQUNyQyxNQUFNUyxxQkFBK0Q7UUFDbkUsT0FBTyxJQUFJLENBQUNaLEdBQUcsQ0FBcUIsR0FBaUIsT0FBZCxJQUFJLENBQUNDLFFBQVEsRUFBQztJQUN2RDtJQUVBLHFCQUFxQjtJQUNyQixNQUFNWSx1QkFDSkMsSUFBVSxFQUNWQyxPQUlDLEVBQzBCO1FBQzNCLE1BQU1DLFdBQVcsSUFBSUM7UUFDckJELFNBQVNFLE1BQU0sQ0FBQyxXQUFXSjtRQUUzQixJQUFJQyxvQkFBQUEsOEJBQUFBLFFBQVNJLGNBQWMsRUFBRTtZQUMzQkgsU0FBU0UsTUFBTSxDQUFDLGtCQUFrQjtRQUNwQztRQUNBLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssZUFBZSxNQUFLQyxXQUFXO1lBQzFDTCxTQUFTRSxNQUFNLENBQUMsbUJBQW1CSCxRQUFRSyxlQUFlLENBQUNFLFFBQVE7UUFDckU7UUFDQSxJQUFJUCxvQkFBQUEsOEJBQUFBLFFBQVNRLFNBQVMsRUFBRTtZQUN0QlAsU0FBU0UsTUFBTSxDQUFDLGFBQWFILFFBQVFRLFNBQVMsQ0FBQ0QsUUFBUTtRQUN6RDtRQUVBLElBQUk7WUFDRixNQUFNRSxXQUFXLE1BQU0sSUFBSSxDQUFDQyxHQUFHLENBQUNuQixJQUFJLENBQW1CLEdBQWlCLE9BQWQsSUFBSSxDQUFDTCxRQUFRLEVBQUMsZ0JBQWNlLFVBQVU7Z0JBQzlGVSxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLFNBQVM7WUFDWDtZQUNBLE9BQU9ILFNBQVNJLElBQUk7UUFDdEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsTUFBTUE7UUFDUjtJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1DLGdCQUFnQkMsUUFBZ0IsRUFBNkI7UUFDakUsT0FBTyxJQUFJLENBQUMvQixHQUFHLENBQU0sR0FBa0MrQixPQUEvQixJQUFJLENBQUM5QixRQUFRLEVBQUMsbUJBQTBCLE9BQVQ4QjtJQUN6RDtJQUVBLGdCQUFnQjtJQUNoQixNQUFNQyxhQUFhRCxRQUFnQixFQUE2QjtRQUM5RCxPQUFPLElBQUksQ0FBQ3pCLElBQUksQ0FBTSxHQUFrQ3lCLE9BQS9CLElBQUksQ0FBQzlCLFFBQVEsRUFBQyxtQkFBMEIsT0FBVDhCO0lBQzFEO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU1FLG1CQUFnRDtRQUNwRCxPQUFPLElBQUksQ0FBQ2pDLEdBQUcsQ0FBUSxHQUFpQixPQUFkLElBQUksQ0FBQ0MsUUFBUSxFQUFDO0lBQzFDOzs7YUF2RmlCQSxXQUFXOztBQXdGOUI7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWlDLGtCQUFrQixJQUFJdkMsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9jdXN0b21lci50cz8wZjZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VBcGlTZXJ2aWNlLCBBcGlSZXNwb25zZSwgUGFnaW5hdGlvblBhcmFtcywgUGFnaW5hdGVkUmVzcG9uc2UgfSBmcm9tICcuL2Jhc2UnO1xuXG4vLyBDdXN0b21lciB0eXBlcyBtYXRjaGluZyBiYWNrZW5kXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyUmVzcG9uc2VEdG8ge1xuICBfaWQ6IHN0cmluZztcbiAgbnVtYmVyOiBudW1iZXI7XG4gIGxvY2F0aW9uTmFtZTogc3RyaW5nO1xuICBkYXRlOiBzdHJpbmc7XG4gIGxvZ2luSG91cjogc3RyaW5nO1xuICB1c2VyTmFtZTogc3RyaW5nO1xuICBiaXJ0aFllYXI6IG51bWJlcjtcbiAgYWN0dWFsQWdlOiBudW1iZXI7XG4gIGdlbmRlcjogJ21hbGUnIHwgJ2ZlbWFsZScgfCAnb3RoZXInO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBkZXZpY2VCcmFuZDogJ3NhbXN1bmcnIHwgJ2FwcGxlJyB8ICdodWF3ZWknIHwgJ3hpYW9taScgfCAnb3BwbycgfCAndml2bycgfCAnb3RoZXInO1xuICBkaWdpdGFsSW50ZXJlc3Q6ICdzb2NpYWxNZWRpYScgfCAnZ2FtaW5nJyB8ICdzaG9wcGluZycgfCAnbmV3cycgfCAnZW50ZXJ0YWlubWVudCcgfCAnZWR1Y2F0aW9uJyB8ICdoZWFsdGgnIHwgJ2ZpbmFuY2UnIHwgJ3RyYXZlbCcgfCAnZm9vZCcgfCAnb3RoZXInO1xuICBsb2NhdGlvblR5cGU6ICd1cmJhbicgfCAnc3VidXJiYW4nIHwgJ3J1cmFsJztcbiAgbG9naW5EYXRlVGltZTogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQ3VzdG9tZXJEdG8ge1xuICBudW1iZXI6IG51bWJlcjtcbiAgbG9jYXRpb25OYW1lOiBzdHJpbmc7XG4gIGRhdGU6IHN0cmluZztcbiAgbG9naW5Ib3VyOiBzdHJpbmc7XG4gIHVzZXJOYW1lOiBzdHJpbmc7XG4gIGJpcnRoWWVhcjogbnVtYmVyO1xuICBnZW5kZXI6ICdtYWxlJyB8ICdmZW1hbGUnIHwgJ290aGVyJztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmVOdW1iZXI6IHN0cmluZztcbiAgZGV2aWNlQnJhbmQ6ICdzYW1zdW5nJyB8ICdhcHBsZScgfCAnaHVhd2VpJyB8ICd4aWFvbWknIHwgJ29wcG8nIHwgJ3Zpdm8nIHwgJ290aGVyJztcbiAgZGlnaXRhbEludGVyZXN0OiAnc29jaWFsTWVkaWEnIHwgJ2dhbWluZycgfCAnc2hvcHBpbmcnIHwgJ25ld3MnIHwgJ2VudGVydGFpbm1lbnQnIHwgJ2VkdWNhdGlvbicgfCAnaGVhbHRoJyB8ICdmaW5hbmNlJyB8ICd0cmF2ZWwnIHwgJ2Zvb2QnIHwgJ290aGVyJztcbiAgbG9jYXRpb25UeXBlOiAndXJiYW4nIHwgJ3N1YnVyYmFuJyB8ICdydXJhbCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlQ3VzdG9tZXJEdG8ge1xuICBsb2NhdGlvbk5hbWU/OiBzdHJpbmc7XG4gIGRhdGU/OiBzdHJpbmc7XG4gIGxvZ2luSG91cj86IHN0cmluZztcbiAgdXNlck5hbWU/OiBzdHJpbmc7XG4gIGJpcnRoWWVhcj86IG51bWJlcjtcbiAgZ2VuZGVyPzogJ21hbGUnIHwgJ2ZlbWFsZScgfCAnb3RoZXInO1xuICBlbWFpbD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIGRldmljZUJyYW5kPzogJ3NhbXN1bmcnIHwgJ2FwcGxlJyB8ICdodWF3ZWknIHwgJ3hpYW9taScgfCAnb3BwbycgfCAndml2bycgfCAnb3RoZXInO1xuICBkaWdpdGFsSW50ZXJlc3Q/OiAnc29jaWFsTWVkaWEnIHwgJ2dhbWluZycgfCAnc2hvcHBpbmcnIHwgJ25ld3MnIHwgJ2VudGVydGFpbm1lbnQnIHwgJ2VkdWNhdGlvbicgfCAnaGVhbHRoJyB8ICdmaW5hbmNlJyB8ICd0cmF2ZWwnIHwgJ2Zvb2QnIHwgJ290aGVyJztcbiAgbG9jYXRpb25UeXBlPzogJ3VyYmFuJyB8ICdzdWJ1cmJhbicgfCAncnVyYWwnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyRmlsdGVycyB7XG4gIGdlbmRlcj86ICdtYWxlJyB8ICdmZW1hbGUnIHwgJ290aGVyJztcbiAgbWluQWdlPzogbnVtYmVyO1xuICBtYXhBZ2U/OiBudW1iZXI7XG4gIGxvY2F0aW9uTmFtZT86IHN0cmluZztcbiAgbG9jYXRpb25UeXBlPzogJ3VyYmFuJyB8ICdzdWJ1cmJhbicgfCAncnVyYWwnO1xuICBkZXZpY2VCcmFuZD86ICdzYW1zdW5nJyB8ICdhcHBsZScgfCAnaHVhd2VpJyB8ICd4aWFvbWknIHwgJ29wcG8nIHwgJ3Zpdm8nIHwgJ290aGVyJztcbiAgZGlnaXRhbEludGVyZXN0PzogJ3NvY2lhbE1lZGlhJyB8ICdnYW1pbmcnIHwgJ3Nob3BwaW5nJyB8ICduZXdzJyB8ICdlbnRlcnRhaW5tZW50JyB8ICdlZHVjYXRpb24nIHwgJ2hlYWx0aCcgfCAnZmluYW5jZScgfCAndHJhdmVsJyB8ICdmb29kJyB8ICdvdGhlcic7XG4gIHN0YXJ0RGF0ZT86IHN0cmluZztcbiAgZW5kRGF0ZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21lclN1bW1hcnlEdG8ge1xuICB0b3RhbEN1c3RvbWVyczogbnVtYmVyO1xuICB1bmlxdWVMb2NhdGlvbnM6IG51bWJlcjtcbiAgYXZnQWdlOiBudW1iZXI7XG4gIGdlbmRlckRpc3RyaWJ1dGlvbjoge1xuICAgIG1hbGU6IG51bWJlcjtcbiAgICBmZW1hbGU6IG51bWJlcjtcbiAgICBvdGhlcjogbnVtYmVyO1xuICB9O1xuICBkZXZpY2VEaXN0cmlidXRpb246IHtcbiAgICBzYW1zdW5nOiBudW1iZXI7XG4gICAgYXBwbGU6IG51bWJlcjtcbiAgICBodWF3ZWk6IG51bWJlcjtcbiAgICB4aWFvbWk6IG51bWJlcjtcbiAgICBvcHBvOiBudW1iZXI7XG4gICAgdml2bzogbnVtYmVyO1xuICAgIG90aGVyOiBudW1iZXI7XG4gIH07XG4gIGxvY2F0aW9uRGlzdHJpYnV0aW9uOiB7XG4gICAgdXJiYW46IG51bWJlcjtcbiAgfTtcbiAgaW50ZXJlc3REaXN0cmlidXRpb246IHtcbiAgICBzb2NpYWxNZWRpYTogbnVtYmVyO1xuICAgIGdhbWluZzogbnVtYmVyO1xuICAgIHNob3BwaW5nOiBudW1iZXI7XG4gICAgbmV3czogbnVtYmVyO1xuICAgIGVudGVydGFpbm1lbnQ6IG51bWJlcjtcbiAgICBlZHVjYXRpb246IG51bWJlcjtcbiAgICBoZWFsdGg6IG51bWJlcjtcbiAgICBmaW5hbmNlOiBudW1iZXI7XG4gICAgdHJhdmVsOiBudW1iZXI7XG4gICAgZm9vZDogbnVtYmVyO1xuICAgIG90aGVyOiBudW1iZXI7XG4gIH07XG4gIGRhdGVSYW5nZToge1xuICAgIGVhcmxpZXN0OiBzdHJpbmcgfCBudWxsO1xuICAgIGxhdGVzdDogc3RyaW5nIHwgbnVsbDtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdpbmF0ZWRDdXN0b21lcnNXaXRoU3VtbWFyeSB7XG4gIGl0ZW1zOiBDdXN0b21lclJlc3BvbnNlRHRvW107XG4gIHRvdGFsOiBudW1iZXI7XG4gIHBhZ2U6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xuICBwYWdlczogbnVtYmVyO1xuICBzdW1tYXJ5PzogQ3VzdG9tZXJTdW1tYXJ5RHRvIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21lcnNXaXRoU3VtbWFyeSBleHRlbmRzIEFycmF5PEN1c3RvbWVyUmVzcG9uc2VEdG8+IHtcbiAgc3VtbWFyeT86IEN1c3RvbWVyU3VtbWFyeUR0byB8IG51bGw7XG59XG5cbi8vIEN1c3RvbWVyIEFQSSBTZXJ2aWNlXG5leHBvcnQgY2xhc3MgQ3VzdG9tZXJTZXJ2aWNlIGV4dGVuZHMgQmFzZUFwaVNlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGVuZHBvaW50ID0gJy9jdXN0b21lcnMnO1xuXG4gIC8vIEdldCBhbGwgY3VzdG9tZXJzIHdpdGggcGFnaW5hdGlvbiBhbmQgZmlsdGVyc1xuICBhc3luYyBnZXRBbGxDdXN0b21lcnMoXG4gICAgcGFnaW5hdGlvbj86IFBhZ2luYXRpb25QYXJhbXMsXG4gICAgZmlsdGVycz86IEN1c3RvbWVyRmlsdGVyc1xuICApOiBQcm9taXNlPEFwaVJlc3BvbnNlPFBhZ2luYXRlZEN1c3RvbWVyc1dpdGhTdW1tYXJ5IHwgQ3VzdG9tZXJzV2l0aFN1bW1hcnk+PiB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgLi4ucGFnaW5hdGlvbixcbiAgICAgIC4uLmZpbHRlcnMsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5nZXQ8UGFnaW5hdGVkQ3VzdG9tZXJzV2l0aFN1bW1hcnkgfCBDdXN0b21lcnNXaXRoU3VtbWFyeT4odGhpcy5lbmRwb2ludCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8vIEdldCBjdXN0b21lciBieSBJRFxuICBhc3luYyBnZXRDdXN0b21lckJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Q3VzdG9tZXJSZXNwb25zZUR0byB8IG51bGw+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0PEN1c3RvbWVyUmVzcG9uc2VEdG8gfCBudWxsPihgJHt0aGlzLmVuZHBvaW50fS8ke2lkfWApO1xuICB9XG5cbiAgLy8gQ3JlYXRlIG5ldyBjdXN0b21lclxuICBhc3luYyBjcmVhdGVDdXN0b21lcihjdXN0b21lckRhdGE6IENyZWF0ZUN1c3RvbWVyRHRvKTogUHJvbWlzZTxBcGlSZXNwb25zZTxDdXN0b21lclJlc3BvbnNlRHRvPj4ge1xuICAgIHJldHVybiB0aGlzLnBvc3Q8Q3VzdG9tZXJSZXNwb25zZUR0bz4odGhpcy5lbmRwb2ludCwgY3VzdG9tZXJEYXRhKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSBjdXN0b21lclxuICBhc3luYyB1cGRhdGVDdXN0b21lcihpZDogc3RyaW5nLCB1cGRhdGVEYXRhOiBVcGRhdGVDdXN0b21lckR0byk6IFByb21pc2U8QXBpUmVzcG9uc2U8Q3VzdG9tZXJSZXNwb25zZUR0byB8IG51bGw+PiB7XG4gICAgcmV0dXJuIHRoaXMucHV0PEN1c3RvbWVyUmVzcG9uc2VEdG8gfCBudWxsPihgJHt0aGlzLmVuZHBvaW50fS8ke2lkfWAsIHVwZGF0ZURhdGEpO1xuICB9XG5cbiAgLy8gRGVsZXRlIGN1c3RvbWVyXG4gIGFzeW5jIGRlbGV0ZUN1c3RvbWVyKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPEN1c3RvbWVyUmVzcG9uc2VEdG8gfCBudWxsPj4ge1xuICAgIHJldHVybiB0aGlzLmRlbGV0ZTxDdXN0b21lclJlc3BvbnNlRHRvIHwgbnVsbD4oYCR7dGhpcy5lbmRwb2ludH0vJHtpZH1gKTtcbiAgfVxuXG4gIC8vIEdldCBjdXN0b21lciBzdW1tYXJ5IGZvciBkYXNoYm9hcmRcbiAgYXN5bmMgZ2V0Q3VzdG9tZXJTdW1tYXJ5KCk6IFByb21pc2U8QXBpUmVzcG9uc2U8Q3VzdG9tZXJTdW1tYXJ5RHRvPj4ge1xuICAgIHJldHVybiB0aGlzLmdldDxDdXN0b21lclN1bW1hcnlEdG8+KGAke3RoaXMuZW5kcG9pbnR9L3N1bW1hcnlgKTtcbiAgfVxuXG4gIC8vIENTViBJbXBvcnQgbWV0aG9kc1xuICBhc3luYyBpbXBvcnRDdXN0b21lcnNGcm9tQ1NWKFxuICAgIGZpbGU6IEZpbGUsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIHNraXBWYWxpZGF0aW9uPzogYm9vbGVhbjtcbiAgICAgIGNvbnRpbnVlT25FcnJvcj86IGJvb2xlYW47XG4gICAgICBiYXRjaFNpemU/OiBudW1iZXI7XG4gICAgfVxuICApOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnY3N2RmlsZScsIGZpbGUpO1xuICAgIFxuICAgIGlmIChvcHRpb25zPy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdza2lwVmFsaWRhdGlvbicsICd0cnVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5jb250aW51ZU9uRXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdjb250aW51ZU9uRXJyb3InLCBvcHRpb25zLmNvbnRpbnVlT25FcnJvci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmJhdGNoU2l6ZSkge1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdiYXRjaFNpemUnLCBvcHRpb25zLmJhdGNoU2l6ZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5wb3N0PEFwaVJlc3BvbnNlPGFueT4+KGAke3RoaXMuZW5kcG9pbnR9L2ltcG9ydC9jc3ZgLCBmb3JtRGF0YSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJyxcbiAgICAgICAgfSxcbiAgICAgICAgdGltZW91dDogNjAwMDAwLCAvLyAxMCBtaW51dGVzIGZvciBsYXJnZSBmaWxlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGltcG9ydCBzdGF0dXNcbiAgYXN5bmMgZ2V0SW1wb3J0U3RhdHVzKGltcG9ydElkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQ8YW55PihgJHt0aGlzLmVuZHBvaW50fS9pbXBvcnQvc3RhdHVzLyR7aW1wb3J0SWR9YCk7XG4gIH1cblxuICAvLyBDYW5jZWwgaW1wb3J0XG4gIGFzeW5jIGNhbmNlbEltcG9ydChpbXBvcnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxhbnk+PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdDxhbnk+KGAke3RoaXMuZW5kcG9pbnR9L2ltcG9ydC9jYW5jZWwvJHtpbXBvcnRJZH1gKTtcbiAgfVxuXG4gIC8vIEdldCBhY3RpdmUgaW1wb3J0c1xuICBhc3luYyBnZXRBY3RpdmVJbXBvcnRzKCk6IFByb21pc2U8QXBpUmVzcG9uc2U8YW55W10+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0PGFueVtdPihgJHt0aGlzLmVuZHBvaW50fS9pbXBvcnQvYWN0aXZlYCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGN1c3RvbWVyU2VydmljZSA9IG5ldyBDdXN0b21lclNlcnZpY2UoKTsiXSwibmFtZXMiOlsiQmFzZUFwaVNlcnZpY2UiLCJDdXN0b21lclNlcnZpY2UiLCJnZXRBbGxDdXN0b21lcnMiLCJwYWdpbmF0aW9uIiwiZmlsdGVycyIsInBhcmFtcyIsImdldCIsImVuZHBvaW50IiwiZ2V0Q3VzdG9tZXJCeUlkIiwiaWQiLCJjcmVhdGVDdXN0b21lciIsImN1c3RvbWVyRGF0YSIsInBvc3QiLCJ1cGRhdGVDdXN0b21lciIsInVwZGF0ZURhdGEiLCJwdXQiLCJkZWxldGVDdXN0b21lciIsImRlbGV0ZSIsImdldEN1c3RvbWVyU3VtbWFyeSIsImltcG9ydEN1c3RvbWVyc0Zyb21DU1YiLCJmaWxlIiwib3B0aW9ucyIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJza2lwVmFsaWRhdGlvbiIsImNvbnRpbnVlT25FcnJvciIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiYmF0Y2hTaXplIiwicmVzcG9uc2UiLCJhcGkiLCJoZWFkZXJzIiwidGltZW91dCIsImRhdGEiLCJlcnJvciIsImdldEltcG9ydFN0YXR1cyIsImltcG9ydElkIiwiY2FuY2VsSW1wb3J0IiwiZ2V0QWN0aXZlSW1wb3J0cyIsImN1c3RvbWVyU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/customer.ts\n"));

/***/ })

});