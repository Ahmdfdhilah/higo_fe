"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/page",{

/***/ "(app-pages-browser)/./src/services/customer.ts":
/*!**********************************!*\
  !*** ./src/services/customer.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerService: function() { return /* binding */ CustomerService; },\n/* harmony export */   customerService: function() { return /* binding */ customerService; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./src/services/base.ts\");\n\n// Customer API Service\nclass CustomerService extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseApiService {\n    // Get all customers with pagination and filters\n    async getAllCustomers(pagination, filters) {\n        const params = {\n            ...pagination,\n            ...filters\n        };\n        return this.get(this.endpoint, params);\n    }\n    // Get customer by ID\n    async getCustomerById(id) {\n        return this.get(\"\".concat(this.endpoint, \"/\").concat(id));\n    }\n    // Create new customer\n    async createCustomer(customerData) {\n        return this.post(this.endpoint, customerData);\n    }\n    // Update customer\n    async updateCustomer(id, updateData) {\n        return this.put(\"\".concat(this.endpoint, \"/\").concat(id), updateData);\n    }\n    // Delete customer\n    async deleteCustomer(id) {\n        return this.delete(\"\".concat(this.endpoint, \"/\").concat(id));\n    }\n    // Get customer summary for dashboard\n    async getCustomerSummary() {\n        return this.get(\"\".concat(this.endpoint, \"/summary\"));\n    }\n    // CSV Import methods\n    async importCustomersFromCSV(file, options) {\n        const formData = new FormData();\n        formData.append(\"csvFile\", file);\n        if (options === null || options === void 0 ? void 0 : options.skipValidation) {\n            formData.append(\"skipValidation\", \"true\");\n        }\n        if ((options === null || options === void 0 ? void 0 : options.continueOnError) !== undefined) {\n            formData.append(\"continueOnError\", options.continueOnError.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.batchSize) {\n            formData.append(\"batchSize\", options.batchSize.toString());\n        }\n        try {\n            const response = await this.api.post(\"\".concat(this.endpoint, \"/import/csv\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                timeout: 600000\n            });\n            return response.data;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Get import status\n    async getImportStatus(importId) {\n        return this.get(\"\".concat(this.endpoint, \"/import/status/\").concat(importId));\n    }\n    // Cancel import\n    async cancelImport(importId) {\n        return this.post(\"\".concat(this.endpoint, \"/import/cancel/\").concat(importId));\n    }\n    // Get active imports\n    async getActiveImports() {\n        return this.get(\"\".concat(this.endpoint, \"/import/active\"));\n    }\n    constructor(...args){\n        super(...args);\n        this.endpoint = \"/customers\";\n    }\n}\n// Export singleton instance\nconst customerService = new CustomerService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jdXN0b21lci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEY7QUFzSDFGLHVCQUF1QjtBQUNoQixNQUFNQyx3QkFBd0JELGlEQUFjQTtJQUdqRCxnREFBZ0Q7SUFDaEQsTUFBTUUsZ0JBQ0pDLFVBQTZCLEVBQzdCQyxPQUF5QixFQUNtRDtRQUM1RSxNQUFNQyxTQUFTO1lBQ2IsR0FBR0YsVUFBVTtZQUNiLEdBQUdDLE9BQU87UUFDWjtRQUNBLE9BQU8sSUFBSSxDQUFDRSxHQUFHLENBQXVELElBQUksQ0FBQ0MsUUFBUSxFQUFFRjtJQUN2RjtJQUVBLHFCQUFxQjtJQUNyQixNQUFNRyxnQkFBZ0JDLEVBQVUsRUFBb0Q7UUFDbEYsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBNkIsR0FBb0JHLE9BQWpCLElBQUksQ0FBQ0YsUUFBUSxFQUFDLEtBQU0sT0FBSEU7SUFDbEU7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUMsZUFBZUMsWUFBK0IsRUFBNkM7UUFDL0YsT0FBTyxJQUFJLENBQUNDLElBQUksQ0FBc0IsSUFBSSxDQUFDTCxRQUFRLEVBQUVJO0lBQ3ZEO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1FLGVBQWVKLEVBQVUsRUFBRUssVUFBNkIsRUFBb0Q7UUFDaEgsT0FBTyxJQUFJLENBQUNDLEdBQUcsQ0FBNkIsR0FBb0JOLE9BQWpCLElBQUksQ0FBQ0YsUUFBUSxFQUFDLEtBQU0sT0FBSEUsS0FBTUs7SUFDeEU7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTUUsZUFBZVAsRUFBVSxFQUFvRDtRQUNqRixPQUFPLElBQUksQ0FBQ1EsTUFBTSxDQUE2QixHQUFvQlIsT0FBakIsSUFBSSxDQUFDRixRQUFRLEVBQUMsS0FBTSxPQUFIRTtJQUNyRTtJQUVBLHFDQUFxQztJQUNyQyxNQUFNUyxxQkFBK0Q7UUFDbkUsT0FBTyxJQUFJLENBQUNaLEdBQUcsQ0FBcUIsR0FBaUIsT0FBZCxJQUFJLENBQUNDLFFBQVEsRUFBQztJQUN2RDtJQUVBLHFCQUFxQjtJQUNyQixNQUFNWSx1QkFDSkMsSUFBVSxFQUNWQyxPQUlDLEVBQzBCO1FBQzNCLE1BQU1DLFdBQVcsSUFBSUM7UUFDckJELFNBQVNFLE1BQU0sQ0FBQyxXQUFXSjtRQUUzQixJQUFJQyxvQkFBQUEsOEJBQUFBLFFBQVNJLGNBQWMsRUFBRTtZQUMzQkgsU0FBU0UsTUFBTSxDQUFDLGtCQUFrQjtRQUNwQztRQUNBLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssZUFBZSxNQUFLQyxXQUFXO1lBQzFDTCxTQUFTRSxNQUFNLENBQUMsbUJBQW1CSCxRQUFRSyxlQUFlLENBQUNFLFFBQVE7UUFDckU7UUFDQSxJQUFJUCxvQkFBQUEsOEJBQUFBLFFBQVNRLFNBQVMsRUFBRTtZQUN0QlAsU0FBU0UsTUFBTSxDQUFDLGFBQWFILFFBQVFRLFNBQVMsQ0FBQ0QsUUFBUTtRQUN6RDtRQUVBLElBQUk7WUFDRixNQUFNRSxXQUFXLE1BQU0sSUFBSSxDQUFDQyxHQUFHLENBQUNuQixJQUFJLENBQW1CLEdBQWlCLE9BQWQsSUFBSSxDQUFDTCxRQUFRLEVBQUMsZ0JBQWNlLFVBQVU7Z0JBQzlGVSxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLFNBQVM7WUFDWDtZQUNBLE9BQU9ILFNBQVNJLElBQUk7UUFDdEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsTUFBTUE7UUFDUjtJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1DLGdCQUFnQkMsUUFBZ0IsRUFBNkI7UUFDakUsT0FBTyxJQUFJLENBQUMvQixHQUFHLENBQU0sR0FBa0MrQixPQUEvQixJQUFJLENBQUM5QixRQUFRLEVBQUMsbUJBQTBCLE9BQVQ4QjtJQUN6RDtJQUVBLGdCQUFnQjtJQUNoQixNQUFNQyxhQUFhRCxRQUFnQixFQUE2QjtRQUM5RCxPQUFPLElBQUksQ0FBQ3pCLElBQUksQ0FBTSxHQUFrQ3lCLE9BQS9CLElBQUksQ0FBQzlCLFFBQVEsRUFBQyxtQkFBMEIsT0FBVDhCO0lBQzFEO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU1FLG1CQUFnRDtRQUNwRCxPQUFPLElBQUksQ0FBQ2pDLEdBQUcsQ0FBUSxHQUFpQixPQUFkLElBQUksQ0FBQ0MsUUFBUSxFQUFDO0lBQzFDOzs7YUF2RmlCQSxXQUFXOztBQXdGOUI7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWlDLGtCQUFrQixJQUFJdkMsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9jdXN0b21lci50cz8wZjZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VBcGlTZXJ2aWNlLCBBcGlSZXNwb25zZSwgUGFnaW5hdGlvblBhcmFtcywgUGFnaW5hdGVkUmVzcG9uc2UgfSBmcm9tICcuL2Jhc2UnO1xuXG4vLyBDdXN0b21lciB0eXBlcyBtYXRjaGluZyBiYWNrZW5kXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyUmVzcG9uc2VEdG8ge1xuICBfaWQ6IHN0cmluZztcbiAgbnVtYmVyOiBudW1iZXI7XG4gIGxvY2F0aW9uTmFtZTogc3RyaW5nO1xuICBkYXRlOiBzdHJpbmc7XG4gIGxvZ2luSG91cjogc3RyaW5nO1xuICB1c2VyTmFtZTogc3RyaW5nO1xuICBiaXJ0aFllYXI6IG51bWJlcjtcbiAgYWN0dWFsQWdlOiBudW1iZXI7XG4gIGdlbmRlcjogJ21hbGUnIHwgJ2ZlbWFsZScgfCAnb3RoZXInO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBkZXZpY2VCcmFuZDogJ3NhbXN1bmcnIHwgJ2FwcGxlJyB8ICdodWF3ZWknIHwgJ3hpYW9taScgfCAnb3BwbycgfCAndml2bycgfCAnb3RoZXInO1xuICBkaWdpdGFsSW50ZXJlc3Q6ICdzb2NpYWxNZWRpYScgfCAnZ2FtaW5nJyB8ICdzaG9wcGluZycgfCAnbmV3cycgfCAnZW50ZXJ0YWlubWVudCcgfCAnZWR1Y2F0aW9uJyB8ICdoZWFsdGgnIHwgJ2ZpbmFuY2UnIHwgJ3RyYXZlbCcgfCAnZm9vZCcgfCAnb3RoZXInO1xuICBsb2NhdGlvblR5cGU6ICd1cmJhbicgfCAnc3VidXJiYW4nIHwgJ3J1cmFsJztcbiAgbG9naW5EYXRlVGltZTogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQ3VzdG9tZXJEdG8ge1xuICBudW1iZXI6IG51bWJlcjtcbiAgbG9jYXRpb25OYW1lOiBzdHJpbmc7XG4gIGRhdGU6IHN0cmluZztcbiAgbG9naW5Ib3VyOiBzdHJpbmc7XG4gIHVzZXJOYW1lOiBzdHJpbmc7XG4gIGJpcnRoWWVhcjogbnVtYmVyO1xuICBnZW5kZXI6ICdtYWxlJyB8ICdmZW1hbGUnIHwgJ290aGVyJztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmVOdW1iZXI6IHN0cmluZztcbiAgZGV2aWNlQnJhbmQ6ICdzYW1zdW5nJyB8ICdhcHBsZScgfCAnaHVhd2VpJyB8ICd4aWFvbWknIHwgJ29wcG8nIHwgJ3Zpdm8nIHwgJ290aGVyJztcbiAgZGlnaXRhbEludGVyZXN0OiAnc29jaWFsTWVkaWEnIHwgJ2dhbWluZycgfCAnc2hvcHBpbmcnIHwgJ25ld3MnIHwgJ2VudGVydGFpbm1lbnQnIHwgJ2VkdWNhdGlvbicgfCAnaGVhbHRoJyB8ICdmaW5hbmNlJyB8ICd0cmF2ZWwnIHwgJ2Zvb2QnIHwgJ290aGVyJztcbiAgbG9jYXRpb25UeXBlOiAndXJiYW4nIHwgJ3N1YnVyYmFuJyB8ICdydXJhbCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlQ3VzdG9tZXJEdG8ge1xuICBsb2NhdGlvbk5hbWU/OiBzdHJpbmc7XG4gIGRhdGU/OiBzdHJpbmc7XG4gIGxvZ2luSG91cj86IHN0cmluZztcbiAgdXNlck5hbWU/OiBzdHJpbmc7XG4gIGJpcnRoWWVhcj86IG51bWJlcjtcbiAgZ2VuZGVyPzogJ21hbGUnIHwgJ2ZlbWFsZScgfCAnb3RoZXInO1xuICBlbWFpbD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIGRldmljZUJyYW5kPzogJ3NhbXN1bmcnIHwgJ2FwcGxlJyB8ICdodWF3ZWknIHwgJ3hpYW9taScgfCAnb3BwbycgfCAndml2bycgfCAnb3RoZXInO1xuICBkaWdpdGFsSW50ZXJlc3Q/OiAnc29jaWFsTWVkaWEnIHwgJ2dhbWluZycgfCAnc2hvcHBpbmcnIHwgJ25ld3MnIHwgJ2VudGVydGFpbm1lbnQnIHwgJ2VkdWNhdGlvbicgfCAnaGVhbHRoJyB8ICdmaW5hbmNlJyB8ICd0cmF2ZWwnIHwgJ2Zvb2QnIHwgJ290aGVyJztcbiAgbG9jYXRpb25UeXBlPzogJ3VyYmFuJyB8ICdzdWJ1cmJhbicgfCAncnVyYWwnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyRmlsdGVycyB7XG4gIGdlbmRlcj86ICdtYWxlJyB8ICdmZW1hbGUnIHwgJ290aGVyJztcbiAgbWluQWdlPzogbnVtYmVyO1xuICBtYXhBZ2U/OiBudW1iZXI7XG4gIGxvY2F0aW9uTmFtZT86IHN0cmluZztcbiAgbG9jYXRpb25UeXBlPzogJ3VyYmFuJyB8ICdzdWJ1cmJhbicgfCAncnVyYWwnO1xuICBkZXZpY2VCcmFuZD86ICdzYW1zdW5nJyB8ICdhcHBsZScgfCAnaHVhd2VpJyB8ICd4aWFvbWknIHwgJ29wcG8nIHwgJ3Zpdm8nIHwgJ290aGVyJztcbiAgZGlnaXRhbEludGVyZXN0PzogJ3NvY2lhbE1lZGlhJyB8ICdnYW1pbmcnIHwgJ3Nob3BwaW5nJyB8ICduZXdzJyB8ICdlbnRlcnRhaW5tZW50JyB8ICdlZHVjYXRpb24nIHwgJ2hlYWx0aCcgfCAnZmluYW5jZScgfCAndHJhdmVsJyB8ICdmb29kJyB8ICdvdGhlcic7XG4gIHN0YXJ0RGF0ZT86IHN0cmluZztcbiAgZW5kRGF0ZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21lclN1bW1hcnlEdG8ge1xuICB0b3RhbEN1c3RvbWVyczogbnVtYmVyO1xuICB1bmlxdWVMb2NhdGlvbnM6IG51bWJlcjtcbiAgYXZnQWdlOiBudW1iZXI7XG4gIGdlbmRlckRpc3RyaWJ1dGlvbjoge1xuICAgIG1hbGU6IG51bWJlcjtcbiAgICBmZW1hbGU6IG51bWJlcjtcbiAgICBvdGhlcjogbnVtYmVyO1xuICB9O1xuICBkZXZpY2VEaXN0cmlidXRpb246IHtcbiAgICBzYW1zdW5nOiBudW1iZXI7XG4gICAgYXBwbGU6IG51bWJlcjtcbiAgICBodWF3ZWk6IG51bWJlcjtcbiAgICB4aWFvbWk6IG51bWJlcjtcbiAgICBvcHBvOiBudW1iZXI7XG4gICAgdml2bzogbnVtYmVyO1xuICAgIG90aGVyOiBudW1iZXI7XG4gIH07XG4gIGxvY2F0aW9uRGlzdHJpYnV0aW9uOiB7XG4gICAgdXJiYW46IG51bWJlcjtcbiAgICBzdWJ1cmJhbjogbnVtYmVyO1xuICB9O1xuICBpbnRlcmVzdERpc3RyaWJ1dGlvbjoge1xuICAgIHNvY2lhbE1lZGlhOiBudW1iZXI7XG4gICAgZ2FtaW5nOiBudW1iZXI7XG4gICAgc2hvcHBpbmc6IG51bWJlcjtcbiAgICBuZXdzOiBudW1iZXI7XG4gICAgZW50ZXJ0YWlubWVudDogbnVtYmVyO1xuICAgIGVkdWNhdGlvbjogbnVtYmVyO1xuICAgIGhlYWx0aDogbnVtYmVyO1xuICAgIGZpbmFuY2U6IG51bWJlcjtcbiAgICB0cmF2ZWw6IG51bWJlcjtcbiAgICBmb29kOiBudW1iZXI7XG4gICAgb3RoZXI6IG51bWJlcjtcbiAgfTtcbiAgZGF0ZVJhbmdlOiB7XG4gICAgZWFybGllc3Q6IHN0cmluZyB8IG51bGw7XG4gICAgbGF0ZXN0OiBzdHJpbmcgfCBudWxsO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luYXRlZEN1c3RvbWVyc1dpdGhTdW1tYXJ5IHtcbiAgaXRlbXM6IEN1c3RvbWVyUmVzcG9uc2VEdG9bXTtcbiAgdG90YWw6IG51bWJlcjtcbiAgcGFnZTogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG4gIHBhZ2VzOiBudW1iZXI7XG4gIHN1bW1hcnk/OiBDdXN0b21lclN1bW1hcnlEdG8gfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyc1dpdGhTdW1tYXJ5IGV4dGVuZHMgQXJyYXk8Q3VzdG9tZXJSZXNwb25zZUR0bz4ge1xuICBzdW1tYXJ5PzogQ3VzdG9tZXJTdW1tYXJ5RHRvIHwgbnVsbDtcbn1cblxuLy8gQ3VzdG9tZXIgQVBJIFNlcnZpY2VcbmV4cG9ydCBjbGFzcyBDdXN0b21lclNlcnZpY2UgZXh0ZW5kcyBCYXNlQXBpU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5kcG9pbnQgPSAnL2N1c3RvbWVycyc7XG5cbiAgLy8gR2V0IGFsbCBjdXN0b21lcnMgd2l0aCBwYWdpbmF0aW9uIGFuZCBmaWx0ZXJzXG4gIGFzeW5jIGdldEFsbEN1c3RvbWVycyhcbiAgICBwYWdpbmF0aW9uPzogUGFnaW5hdGlvblBhcmFtcyxcbiAgICBmaWx0ZXJzPzogQ3VzdG9tZXJGaWx0ZXJzXG4gICk6IFByb21pc2U8QXBpUmVzcG9uc2U8UGFnaW5hdGVkQ3VzdG9tZXJzV2l0aFN1bW1hcnkgfCBDdXN0b21lcnNXaXRoU3VtbWFyeT4+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAuLi5wYWdpbmF0aW9uLFxuICAgICAgLi4uZmlsdGVycyxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldDxQYWdpbmF0ZWRDdXN0b21lcnNXaXRoU3VtbWFyeSB8IEN1c3RvbWVyc1dpdGhTdW1tYXJ5Pih0aGlzLmVuZHBvaW50LCBwYXJhbXMpO1xuICB9XG5cbiAgLy8gR2V0IGN1c3RvbWVyIGJ5IElEXG4gIGFzeW5jIGdldEN1c3RvbWVyQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxDdXN0b21lclJlc3BvbnNlRHRvIHwgbnVsbD4+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQ8Q3VzdG9tZXJSZXNwb25zZUR0byB8IG51bGw+KGAke3RoaXMuZW5kcG9pbnR9LyR7aWR9YCk7XG4gIH1cblxuICAvLyBDcmVhdGUgbmV3IGN1c3RvbWVyXG4gIGFzeW5jIGNyZWF0ZUN1c3RvbWVyKGN1c3RvbWVyRGF0YTogQ3JlYXRlQ3VzdG9tZXJEdG8pOiBQcm9taXNlPEFwaVJlc3BvbnNlPEN1c3RvbWVyUmVzcG9uc2VEdG8+PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdDxDdXN0b21lclJlc3BvbnNlRHRvPih0aGlzLmVuZHBvaW50LCBjdXN0b21lckRhdGEpO1xuICB9XG5cbiAgLy8gVXBkYXRlIGN1c3RvbWVyXG4gIGFzeW5jIHVwZGF0ZUN1c3RvbWVyKGlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IFVwZGF0ZUN1c3RvbWVyRHRvKTogUHJvbWlzZTxBcGlSZXNwb25zZTxDdXN0b21lclJlc3BvbnNlRHRvIHwgbnVsbD4+IHtcbiAgICByZXR1cm4gdGhpcy5wdXQ8Q3VzdG9tZXJSZXNwb25zZUR0byB8IG51bGw+KGAke3RoaXMuZW5kcG9pbnR9LyR7aWR9YCwgdXBkYXRlRGF0YSk7XG4gIH1cblxuICAvLyBEZWxldGUgY3VzdG9tZXJcbiAgYXN5bmMgZGVsZXRlQ3VzdG9tZXIoaWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8Q3VzdG9tZXJSZXNwb25zZUR0byB8IG51bGw+PiB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZXRlPEN1c3RvbWVyUmVzcG9uc2VEdG8gfCBudWxsPihgJHt0aGlzLmVuZHBvaW50fS8ke2lkfWApO1xuICB9XG5cbiAgLy8gR2V0IGN1c3RvbWVyIHN1bW1hcnkgZm9yIGRhc2hib2FyZFxuICBhc3luYyBnZXRDdXN0b21lclN1bW1hcnkoKTogUHJvbWlzZTxBcGlSZXNwb25zZTxDdXN0b21lclN1bW1hcnlEdG8+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0PEN1c3RvbWVyU3VtbWFyeUR0bz4oYCR7dGhpcy5lbmRwb2ludH0vc3VtbWFyeWApO1xuICB9XG5cbiAgLy8gQ1NWIEltcG9ydCBtZXRob2RzXG4gIGFzeW5jIGltcG9ydEN1c3RvbWVyc0Zyb21DU1YoXG4gICAgZmlsZTogRmlsZSxcbiAgICBvcHRpb25zPzoge1xuICAgICAgc2tpcFZhbGlkYXRpb24/OiBib29sZWFuO1xuICAgICAgY29udGludWVPbkVycm9yPzogYm9vbGVhbjtcbiAgICAgIGJhdGNoU2l6ZT86IG51bWJlcjtcbiAgICB9XG4gICk6IFByb21pc2U8QXBpUmVzcG9uc2U8YW55Pj4ge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdjc3ZGaWxlJywgZmlsZSk7XG4gICAgXG4gICAgaWYgKG9wdGlvbnM/LnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ3NraXBWYWxpZGF0aW9uJywgJ3RydWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmNvbnRpbnVlT25FcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2NvbnRpbnVlT25FcnJvcicsIG9wdGlvbnMuY29udGludWVPbkVycm9yLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uYmF0Y2hTaXplKSB7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2JhdGNoU2l6ZScsIG9wdGlvbnMuYmF0Y2hTaXplLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpLnBvc3Q8QXBpUmVzcG9uc2U8YW55Pj4oYCR7dGhpcy5lbmRwb2ludH0vaW1wb3J0L2NzdmAsIGZvcm1EYXRhLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgICB9LFxuICAgICAgICB0aW1lb3V0OiA2MDAwMDAsIC8vIDEwIG1pbnV0ZXMgZm9yIGxhcmdlIGZpbGVzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgaW1wb3J0IHN0YXR1c1xuICBhc3luYyBnZXRJbXBvcnRTdGF0dXMoaW1wb3J0SWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLmdldDxhbnk+KGAke3RoaXMuZW5kcG9pbnR9L2ltcG9ydC9zdGF0dXMvJHtpbXBvcnRJZH1gKTtcbiAgfVxuXG4gIC8vIENhbmNlbCBpbXBvcnRcbiAgYXN5bmMgY2FuY2VsSW1wb3J0KGltcG9ydElkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueT4+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0PGFueT4oYCR7dGhpcy5lbmRwb2ludH0vaW1wb3J0L2NhbmNlbC8ke2ltcG9ydElkfWApO1xuICB9XG5cbiAgLy8gR2V0IGFjdGl2ZSBpbXBvcnRzXG4gIGFzeW5jIGdldEFjdGl2ZUltcG9ydHMoKTogUHJvbWlzZTxBcGlSZXNwb25zZTxhbnlbXT4+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQ8YW55W10+KGAke3RoaXMuZW5kcG9pbnR9L2ltcG9ydC9hY3RpdmVgKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgY3VzdG9tZXJTZXJ2aWNlID0gbmV3IEN1c3RvbWVyU2VydmljZSgpOyJdLCJuYW1lcyI6WyJCYXNlQXBpU2VydmljZSIsIkN1c3RvbWVyU2VydmljZSIsImdldEFsbEN1c3RvbWVycyIsInBhZ2luYXRpb24iLCJmaWx0ZXJzIiwicGFyYW1zIiwiZ2V0IiwiZW5kcG9pbnQiLCJnZXRDdXN0b21lckJ5SWQiLCJpZCIsImNyZWF0ZUN1c3RvbWVyIiwiY3VzdG9tZXJEYXRhIiwicG9zdCIsInVwZGF0ZUN1c3RvbWVyIiwidXBkYXRlRGF0YSIsInB1dCIsImRlbGV0ZUN1c3RvbWVyIiwiZGVsZXRlIiwiZ2V0Q3VzdG9tZXJTdW1tYXJ5IiwiaW1wb3J0Q3VzdG9tZXJzRnJvbUNTViIsImZpbGUiLCJvcHRpb25zIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInNraXBWYWxpZGF0aW9uIiwiY29udGludWVPbkVycm9yIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJiYXRjaFNpemUiLCJyZXNwb25zZSIsImFwaSIsImhlYWRlcnMiLCJ0aW1lb3V0IiwiZGF0YSIsImVycm9yIiwiZ2V0SW1wb3J0U3RhdHVzIiwiaW1wb3J0SWQiLCJjYW5jZWxJbXBvcnQiLCJnZXRBY3RpdmVJbXBvcnRzIiwiY3VzdG9tZXJTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/customer.ts\n"));

/***/ })

});