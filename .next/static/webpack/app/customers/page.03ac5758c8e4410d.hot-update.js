"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/customers/page",{

/***/ "(app-pages-browser)/./src/services/customer.ts":
/*!**********************************!*\
  !*** ./src/services/customer.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomerService: function() { return /* binding */ CustomerService; },\n/* harmony export */   customerService: function() { return /* binding */ customerService; }\n/* harmony export */ });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"(app-pages-browser)/./src/services/base.ts\");\n\n// Customer API Service\nclass CustomerService extends _base__WEBPACK_IMPORTED_MODULE_0__.BaseApiService {\n    // Get all customers with pagination and filters\n    async getAllCustomers(pagination, filters) {\n        const params = {\n            ...pagination,\n            ...filters\n        };\n        return this.get(this.endpoint, params);\n    }\n    // Get customer by ID\n    async getCustomerById(id) {\n        return this.get(\"\".concat(this.endpoint, \"/\").concat(id));\n    }\n    // Create new customer\n    async createCustomer(customerData) {\n        return this.post(this.endpoint, customerData);\n    }\n    // Update customer\n    async updateCustomer(id, updateData) {\n        return this.put(\"\".concat(this.endpoint, \"/\").concat(id), updateData);\n    }\n    // Delete customer\n    async deleteCustomer(id) {\n        return this.delete(\"\".concat(this.endpoint, \"/\").concat(id));\n    }\n    // Get customer summary for dashboard\n    async getCustomerSummary() {\n        return this.get(\"\".concat(this.endpoint, \"/summary\"));\n    }\n    // CSV Import methods\n    async importCustomersFromCSV(file, options) {\n        const formData = new FormData();\n        formData.append(\"csvFile\", file);\n        if (options === null || options === void 0 ? void 0 : options.skipValidation) {\n            formData.append(\"skipValidation\", \"true\");\n        }\n        if ((options === null || options === void 0 ? void 0 : options.continueOnError) !== undefined) {\n            formData.append(\"continueOnError\", options.continueOnError.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.batchSize) {\n            formData.append(\"batchSize\", options.batchSize.toString());\n        }\n        try {\n            const response = await this.api.post(\"\".concat(this.endpoint, \"/import/csv\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                timeout: 600000\n            });\n            return response.data;\n        } catch (error) {\n            throw error;\n        }\n    }\n    // Get import status\n    async getImportStatus(importId) {\n        return this.get(\"\".concat(this.endpoint, \"/import/status/\").concat(importId));\n    }\n    // Cancel import\n    async cancelImport(importId) {\n        return this.post(\"\".concat(this.endpoint, \"/import/cancel/\").concat(importId));\n    }\n    // Get active imports\n    async getActiveImports() {\n        return this.get(\"\".concat(this.endpoint, \"/import/active\"));\n    }\n    constructor(...args){\n        super(...args);\n        this.endpoint = \"/customers\";\n    }\n}\n// Export singleton instance\nconst customerService = new CustomerService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jdXN0b21lci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEY7QUF1SDFGLHVCQUF1QjtBQUNoQixNQUFNQyx3QkFBd0JELGlEQUFjQTtJQUdqRCxnREFBZ0Q7SUFDaEQsTUFBTUUsZ0JBQ0pDLFVBQTZCLEVBQzdCQyxPQUF5QixFQUNtRDtRQUM1RSxNQUFNQyxTQUFTO1lBQ2IsR0FBR0YsVUFBVTtZQUNiLEdBQUdDLE9BQU87UUFDWjtRQUNBLE9BQU8sSUFBSSxDQUFDRSxHQUFHLENBQXVELElBQUksQ0FBQ0MsUUFBUSxFQUFFRjtJQUN2RjtJQUVBLHFCQUFxQjtJQUNyQixNQUFNRyxnQkFBZ0JDLEVBQVUsRUFBb0Q7UUFDbEYsT0FBTyxJQUFJLENBQUNILEdBQUcsQ0FBNkIsR0FBb0JHLE9BQWpCLElBQUksQ0FBQ0YsUUFBUSxFQUFDLEtBQU0sT0FBSEU7SUFDbEU7SUFFQSxzQkFBc0I7SUFDdEIsTUFBTUMsZUFBZUMsWUFBK0IsRUFBNkM7UUFDL0YsT0FBTyxJQUFJLENBQUNDLElBQUksQ0FBc0IsSUFBSSxDQUFDTCxRQUFRLEVBQUVJO0lBQ3ZEO0lBRUEsa0JBQWtCO0lBQ2xCLE1BQU1FLGVBQWVKLEVBQVUsRUFBRUssVUFBNkIsRUFBb0Q7UUFDaEgsT0FBTyxJQUFJLENBQUNDLEdBQUcsQ0FBNkIsR0FBb0JOLE9BQWpCLElBQUksQ0FBQ0YsUUFBUSxFQUFDLEtBQU0sT0FBSEUsS0FBTUs7SUFDeEU7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTUUsZUFBZVAsRUFBVSxFQUFvRDtRQUNqRixPQUFPLElBQUksQ0FBQ1EsTUFBTSxDQUE2QixHQUFvQlIsT0FBakIsSUFBSSxDQUFDRixRQUFRLEVBQUMsS0FBTSxPQUFIRTtJQUNyRTtJQUVBLHFDQUFxQztJQUNyQyxNQUFNUyxxQkFBK0Q7UUFDbkUsT0FBTyxJQUFJLENBQUNaLEdBQUcsQ0FBcUIsR0FBaUIsT0FBZCxJQUFJLENBQUNDLFFBQVEsRUFBQztJQUN2RDtJQUVBLHFCQUFxQjtJQUNyQixNQUFNWSx1QkFDSkMsSUFBVSxFQUNWQyxPQUlDLEVBQzBCO1FBQzNCLE1BQU1DLFdBQVcsSUFBSUM7UUFDckJELFNBQVNFLE1BQU0sQ0FBQyxXQUFXSjtRQUUzQixJQUFJQyxvQkFBQUEsOEJBQUFBLFFBQVNJLGNBQWMsRUFBRTtZQUMzQkgsU0FBU0UsTUFBTSxDQUFDLGtCQUFrQjtRQUNwQztRQUNBLElBQUlILENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssZUFBZSxNQUFLQyxXQUFXO1lBQzFDTCxTQUFTRSxNQUFNLENBQUMsbUJBQW1CSCxRQUFRSyxlQUFlLENBQUNFLFFBQVE7UUFDckU7UUFDQSxJQUFJUCxvQkFBQUEsOEJBQUFBLFFBQVNRLFNBQVMsRUFBRTtZQUN0QlAsU0FBU0UsTUFBTSxDQUFDLGFBQWFILFFBQVFRLFNBQVMsQ0FBQ0QsUUFBUTtRQUN6RDtRQUVBLElBQUk7WUFDRixNQUFNRSxXQUFXLE1BQU0sSUFBSSxDQUFDQyxHQUFHLENBQUNuQixJQUFJLENBQW1CLEdBQWlCLE9BQWQsSUFBSSxDQUFDTCxRQUFRLEVBQUMsZ0JBQWNlLFVBQVU7Z0JBQzlGVSxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLFNBQVM7WUFDWDtZQUNBLE9BQU9ILFNBQVNJLElBQUk7UUFDdEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsTUFBTUE7UUFDUjtJQUNGO0lBRUEsb0JBQW9CO0lBQ3BCLE1BQU1DLGdCQUFnQkMsUUFBZ0IsRUFBNkI7UUFDakUsT0FBTyxJQUFJLENBQUMvQixHQUFHLENBQU0sR0FBa0MrQixPQUEvQixJQUFJLENBQUM5QixRQUFRLEVBQUMsbUJBQTBCLE9BQVQ4QjtJQUN6RDtJQUVBLGdCQUFnQjtJQUNoQixNQUFNQyxhQUFhRCxRQUFnQixFQUE2QjtRQUM5RCxPQUFPLElBQUksQ0FBQ3pCLElBQUksQ0FBTSxHQUFrQ3lCLE9BQS9CLElBQUksQ0FBQzlCLFFBQVEsRUFBQyxtQkFBMEIsT0FBVDhCO0lBQzFEO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU1FLG1CQUFnRDtRQUNwRCxPQUFPLElBQUksQ0FBQ2pDLEdBQUcsQ0FBUSxHQUFpQixPQUFkLElBQUksQ0FBQ0MsUUFBUSxFQUFDO0lBQzFDOzs7YUF2RmlCQSxXQUFXOztBQXdGOUI7QUFFQSw0QkFBNEI7QUFDckIsTUFBTWlDLGtCQUFrQixJQUFJdkMsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zZXJ2aWNlcy9jdXN0b21lci50cz8wZjZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VBcGlTZXJ2aWNlLCBBcGlSZXNwb25zZSwgUGFnaW5hdGlvblBhcmFtcywgUGFnaW5hdGVkUmVzcG9uc2UgfSBmcm9tICcuL2Jhc2UnO1xuXG4vLyBDdXN0b21lciB0eXBlcyBtYXRjaGluZyBiYWNrZW5kXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyUmVzcG9uc2VEdG8ge1xuICBfaWQ6IHN0cmluZztcbiAgbnVtYmVyOiBudW1iZXI7XG4gIGxvY2F0aW9uTmFtZTogc3RyaW5nO1xuICBkYXRlOiBzdHJpbmc7XG4gIGxvZ2luSG91cjogc3RyaW5nO1xuICB1c2VyTmFtZTogc3RyaW5nO1xuICBiaXJ0aFllYXI6IG51bWJlcjtcbiAgYWN0dWFsQWdlOiBudW1iZXI7XG4gIGdlbmRlcjogJ21hbGUnIHwgJ2ZlbWFsZScgfCAnb3RoZXInO1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZU51bWJlcjogc3RyaW5nO1xuICBkZXZpY2VCcmFuZDogJ3NhbXN1bmcnIHwgJ2FwcGxlJyB8ICdodWF3ZWknIHwgJ3hpYW9taScgfCAnb3BwbycgfCAndml2bycgfCAnb3RoZXInO1xuICBkaWdpdGFsSW50ZXJlc3Q6ICdzb2NpYWxNZWRpYScgfCAnZ2FtaW5nJyB8ICdzaG9wcGluZycgfCAnbmV3cycgfCAnZW50ZXJ0YWlubWVudCcgfCAnZWR1Y2F0aW9uJyB8ICdoZWFsdGgnIHwgJ2ZpbmFuY2UnIHwgJ3RyYXZlbCcgfCAnZm9vZCcgfCAnb3RoZXInO1xuICBsb2NhdGlvblR5cGU6ICd1cmJhbicgfCAnc3VidXJiYW4nIHwgJ3J1cmFsJztcbiAgbG9naW5EYXRlVGltZTogc3RyaW5nO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgdXBkYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQ3VzdG9tZXJEdG8ge1xuICBudW1iZXI6IG51bWJlcjtcbiAgbG9jYXRpb25OYW1lOiBzdHJpbmc7XG4gIGRhdGU6IHN0cmluZztcbiAgbG9naW5Ib3VyOiBzdHJpbmc7XG4gIHVzZXJOYW1lOiBzdHJpbmc7XG4gIGJpcnRoWWVhcjogbnVtYmVyO1xuICBnZW5kZXI6ICdtYWxlJyB8ICdmZW1hbGUnIHwgJ290aGVyJztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmVOdW1iZXI6IHN0cmluZztcbiAgZGV2aWNlQnJhbmQ6ICdzYW1zdW5nJyB8ICdhcHBsZScgfCAnaHVhd2VpJyB8ICd4aWFvbWknIHwgJ29wcG8nIHwgJ3Zpdm8nIHwgJ290aGVyJztcbiAgZGlnaXRhbEludGVyZXN0OiAnc29jaWFsTWVkaWEnIHwgJ2dhbWluZycgfCAnc2hvcHBpbmcnIHwgJ25ld3MnIHwgJ2VudGVydGFpbm1lbnQnIHwgJ2VkdWNhdGlvbicgfCAnaGVhbHRoJyB8ICdmaW5hbmNlJyB8ICd0cmF2ZWwnIHwgJ2Zvb2QnIHwgJ290aGVyJztcbiAgbG9jYXRpb25UeXBlOiAndXJiYW4nIHwgJ3N1YnVyYmFuJyB8ICdydXJhbCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBkYXRlQ3VzdG9tZXJEdG8ge1xuICBsb2NhdGlvbk5hbWU/OiBzdHJpbmc7XG4gIGRhdGU/OiBzdHJpbmc7XG4gIGxvZ2luSG91cj86IHN0cmluZztcbiAgdXNlck5hbWU/OiBzdHJpbmc7XG4gIGJpcnRoWWVhcj86IG51bWJlcjtcbiAgZ2VuZGVyPzogJ21hbGUnIHwgJ2ZlbWFsZScgfCAnb3RoZXInO1xuICBlbWFpbD86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG4gIGRldmljZUJyYW5kPzogJ3NhbXN1bmcnIHwgJ2FwcGxlJyB8ICdodWF3ZWknIHwgJ3hpYW9taScgfCAnb3BwbycgfCAndml2bycgfCAnb3RoZXInO1xuICBkaWdpdGFsSW50ZXJlc3Q/OiAnc29jaWFsTWVkaWEnIHwgJ2dhbWluZycgfCAnc2hvcHBpbmcnIHwgJ25ld3MnIHwgJ2VudGVydGFpbm1lbnQnIHwgJ2VkdWNhdGlvbicgfCAnaGVhbHRoJyB8ICdmaW5hbmNlJyB8ICd0cmF2ZWwnIHwgJ2Zvb2QnIHwgJ290aGVyJztcbiAgbG9jYXRpb25UeXBlPzogJ3VyYmFuJyB8ICdzdWJ1cmJhbicgfCAncnVyYWwnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbWVyRmlsdGVycyB7XG4gIGdlbmRlcj86ICdtYWxlJyB8ICdmZW1hbGUnIHwgJ290aGVyJztcbiAgbWluQWdlPzogbnVtYmVyO1xuICBtYXhBZ2U/OiBudW1iZXI7XG4gIGxvY2F0aW9uTmFtZT86IHN0cmluZztcbiAgbG9jYXRpb25UeXBlPzogJ3VyYmFuJyB8ICdzdWJ1cmJhbicgfCAncnVyYWwnO1xuICBkZXZpY2VCcmFuZD86ICdzYW1zdW5nJyB8ICdhcHBsZScgfCAnaHVhd2VpJyB8ICd4aWFvbWknIHwgJ29wcG8nIHwgJ3Zpdm8nIHwgJ290aGVyJztcbiAgZGlnaXRhbEludGVyZXN0PzogJ3NvY2lhbE1lZGlhJyB8ICdnYW1pbmcnIHwgJ3Nob3BwaW5nJyB8ICduZXdzJyB8ICdlbnRlcnRhaW5tZW50JyB8ICdlZHVjYXRpb24nIHwgJ2hlYWx0aCcgfCAnZmluYW5jZScgfCAndHJhdmVsJyB8ICdmb29kJyB8ICdvdGhlcic7XG4gIHN0YXJ0RGF0ZT86IHN0cmluZztcbiAgZW5kRGF0ZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21lclN1bW1hcnlEdG8ge1xuICB0b3RhbEN1c3RvbWVyczogbnVtYmVyO1xuICB1bmlxdWVMb2NhdGlvbnM6IG51bWJlcjtcbiAgYXZnQWdlOiBudW1iZXI7XG4gIGdlbmRlckRpc3RyaWJ1dGlvbjoge1xuICAgIG1hbGU6IG51bWJlcjtcbiAgICBmZW1hbGU6IG51bWJlcjtcbiAgICBvdGhlcjogbnVtYmVyO1xuICB9O1xuICBkZXZpY2VEaXN0cmlidXRpb246IHtcbiAgICBzYW1zdW5nOiBudW1iZXI7XG4gICAgYXBwbGU6IG51bWJlcjtcbiAgICBodWF3ZWk6IG51bWJlcjtcbiAgICB4aWFvbWk6IG51bWJlcjtcbiAgICBvcHBvOiBudW1iZXI7XG4gICAgdml2bzogbnVtYmVyO1xuICAgIG90aGVyOiBudW1iZXI7XG4gIH07XG4gIGxvY2F0aW9uRGlzdHJpYnV0aW9uOiB7XG4gICAgdXJiYW46IG51bWJlcjtcbiAgICBzdWJ1cmJhbjogbnVtYmVyO1xuICAgIHJ1cmFsOiBudW1iZXI7XG4gIH07XG4gIGludGVyZXN0RGlzdHJpYnV0aW9uOiB7XG4gICAgc29jaWFsTWVkaWE6IG51bWJlcjtcbiAgICBnYW1pbmc6IG51bWJlcjtcbiAgICBzaG9wcGluZzogbnVtYmVyO1xuICAgIG5ld3M6IG51bWJlcjtcbiAgICBlbnRlcnRhaW5tZW50OiBudW1iZXI7XG4gICAgZWR1Y2F0aW9uOiBudW1iZXI7XG4gICAgaGVhbHRoOiBudW1iZXI7XG4gICAgZmluYW5jZTogbnVtYmVyO1xuICAgIHRyYXZlbDogbnVtYmVyO1xuICAgIGZvb2Q6IG51bWJlcjtcbiAgICBvdGhlcjogbnVtYmVyO1xuICB9O1xuICBkYXRlUmFuZ2U6IHtcbiAgICBlYXJsaWVzdDogc3RyaW5nIHwgbnVsbDtcbiAgICBsYXRlc3Q6IHN0cmluZyB8IG51bGw7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5hdGVkQ3VzdG9tZXJzV2l0aFN1bW1hcnkge1xuICBpdGVtczogQ3VzdG9tZXJSZXNwb25zZUR0b1tdO1xuICB0b3RhbDogbnVtYmVyO1xuICBwYWdlOiBudW1iZXI7XG4gIHNpemU6IG51bWJlcjtcbiAgcGFnZXM6IG51bWJlcjtcbiAgc3VtbWFyeT86IEN1c3RvbWVyU3VtbWFyeUR0byB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tZXJzV2l0aFN1bW1hcnkgZXh0ZW5kcyBBcnJheTxDdXN0b21lclJlc3BvbnNlRHRvPiB7XG4gIHN1bW1hcnk/OiBDdXN0b21lclN1bW1hcnlEdG8gfCBudWxsO1xufVxuXG4vLyBDdXN0b21lciBBUEkgU2VydmljZVxuZXhwb3J0IGNsYXNzIEN1c3RvbWVyU2VydmljZSBleHRlbmRzIEJhc2VBcGlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBlbmRwb2ludCA9ICcvY3VzdG9tZXJzJztcblxuICAvLyBHZXQgYWxsIGN1c3RvbWVycyB3aXRoIHBhZ2luYXRpb24gYW5kIGZpbHRlcnNcbiAgYXN5bmMgZ2V0QWxsQ3VzdG9tZXJzKFxuICAgIHBhZ2luYXRpb24/OiBQYWdpbmF0aW9uUGFyYW1zLFxuICAgIGZpbHRlcnM/OiBDdXN0b21lckZpbHRlcnNcbiAgKTogUHJvbWlzZTxBcGlSZXNwb25zZTxQYWdpbmF0ZWRDdXN0b21lcnNXaXRoU3VtbWFyeSB8IEN1c3RvbWVyc1dpdGhTdW1tYXJ5Pj4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIC4uLnBhZ2luYXRpb24sXG4gICAgICAuLi5maWx0ZXJzLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuZ2V0PFBhZ2luYXRlZEN1c3RvbWVyc1dpdGhTdW1tYXJ5IHwgQ3VzdG9tZXJzV2l0aFN1bW1hcnk+KHRoaXMuZW5kcG9pbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvLyBHZXQgY3VzdG9tZXIgYnkgSURcbiAgYXN5bmMgZ2V0Q3VzdG9tZXJCeUlkKGlkOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPEN1c3RvbWVyUmVzcG9uc2VEdG8gfCBudWxsPj4ge1xuICAgIHJldHVybiB0aGlzLmdldDxDdXN0b21lclJlc3BvbnNlRHRvIHwgbnVsbD4oYCR7dGhpcy5lbmRwb2ludH0vJHtpZH1gKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBuZXcgY3VzdG9tZXJcbiAgYXN5bmMgY3JlYXRlQ3VzdG9tZXIoY3VzdG9tZXJEYXRhOiBDcmVhdGVDdXN0b21lckR0byk6IFByb21pc2U8QXBpUmVzcG9uc2U8Q3VzdG9tZXJSZXNwb25zZUR0bz4+IHtcbiAgICByZXR1cm4gdGhpcy5wb3N0PEN1c3RvbWVyUmVzcG9uc2VEdG8+KHRoaXMuZW5kcG9pbnQsIGN1c3RvbWVyRGF0YSk7XG4gIH1cblxuICAvLyBVcGRhdGUgY3VzdG9tZXJcbiAgYXN5bmMgdXBkYXRlQ3VzdG9tZXIoaWQ6IHN0cmluZywgdXBkYXRlRGF0YTogVXBkYXRlQ3VzdG9tZXJEdG8pOiBQcm9taXNlPEFwaVJlc3BvbnNlPEN1c3RvbWVyUmVzcG9uc2VEdG8gfCBudWxsPj4ge1xuICAgIHJldHVybiB0aGlzLnB1dDxDdXN0b21lclJlc3BvbnNlRHRvIHwgbnVsbD4oYCR7dGhpcy5lbmRwb2ludH0vJHtpZH1gLCB1cGRhdGVEYXRhKTtcbiAgfVxuXG4gIC8vIERlbGV0ZSBjdXN0b21lclxuICBhc3luYyBkZWxldGVDdXN0b21lcihpZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxDdXN0b21lclJlc3BvbnNlRHRvIHwgbnVsbD4+IHtcbiAgICByZXR1cm4gdGhpcy5kZWxldGU8Q3VzdG9tZXJSZXNwb25zZUR0byB8IG51bGw+KGAke3RoaXMuZW5kcG9pbnR9LyR7aWR9YCk7XG4gIH1cblxuICAvLyBHZXQgY3VzdG9tZXIgc3VtbWFyeSBmb3IgZGFzaGJvYXJkXG4gIGFzeW5jIGdldEN1c3RvbWVyU3VtbWFyeSgpOiBQcm9taXNlPEFwaVJlc3BvbnNlPEN1c3RvbWVyU3VtbWFyeUR0bz4+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQ8Q3VzdG9tZXJTdW1tYXJ5RHRvPihgJHt0aGlzLmVuZHBvaW50fS9zdW1tYXJ5YCk7XG4gIH1cblxuICAvLyBDU1YgSW1wb3J0IG1ldGhvZHNcbiAgYXN5bmMgaW1wb3J0Q3VzdG9tZXJzRnJvbUNTVihcbiAgICBmaWxlOiBGaWxlLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBza2lwVmFsaWRhdGlvbj86IGJvb2xlYW47XG4gICAgICBjb250aW51ZU9uRXJyb3I/OiBib29sZWFuO1xuICAgICAgYmF0Y2hTaXplPzogbnVtYmVyO1xuICAgIH1cbiAgKTogUHJvbWlzZTxBcGlSZXNwb25zZTxhbnk+PiB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ2NzdkZpbGUnLCBmaWxlKTtcbiAgICBcbiAgICBpZiAob3B0aW9ucz8uc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnc2tpcFZhbGlkYXRpb24nLCAndHJ1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uY29udGludWVPbkVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnY29udGludWVPbkVycm9yJywgb3B0aW9ucy5jb250aW51ZU9uRXJyb3IudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5iYXRjaFNpemUpIHtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnYmF0Y2hTaXplJywgb3B0aW9ucy5iYXRjaFNpemUudG9TdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkucG9zdDxBcGlSZXNwb25zZTxhbnk+PihgJHt0aGlzLmVuZHBvaW50fS9pbXBvcnQvY3N2YCwgZm9ybURhdGEsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IDYwMDAwMCwgLy8gMTAgbWludXRlcyBmb3IgbGFyZ2UgZmlsZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBpbXBvcnQgc3RhdHVzXG4gIGFzeW5jIGdldEltcG9ydFN0YXR1cyhpbXBvcnRJZDogc3RyaW5nKTogUHJvbWlzZTxBcGlSZXNwb25zZTxhbnk+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0PGFueT4oYCR7dGhpcy5lbmRwb2ludH0vaW1wb3J0L3N0YXR1cy8ke2ltcG9ydElkfWApO1xuICB9XG5cbiAgLy8gQ2FuY2VsIGltcG9ydFxuICBhc3luYyBjYW5jZWxJbXBvcnQoaW1wb3J0SWQ6IHN0cmluZyk6IFByb21pc2U8QXBpUmVzcG9uc2U8YW55Pj4ge1xuICAgIHJldHVybiB0aGlzLnBvc3Q8YW55PihgJHt0aGlzLmVuZHBvaW50fS9pbXBvcnQvY2FuY2VsLyR7aW1wb3J0SWR9YCk7XG4gIH1cblxuICAvLyBHZXQgYWN0aXZlIGltcG9ydHNcbiAgYXN5bmMgZ2V0QWN0aXZlSW1wb3J0cygpOiBQcm9taXNlPEFwaVJlc3BvbnNlPGFueVtdPj4ge1xuICAgIHJldHVybiB0aGlzLmdldDxhbnlbXT4oYCR7dGhpcy5lbmRwb2ludH0vaW1wb3J0L2FjdGl2ZWApO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBjdXN0b21lclNlcnZpY2UgPSBuZXcgQ3VzdG9tZXJTZXJ2aWNlKCk7Il0sIm5hbWVzIjpbIkJhc2VBcGlTZXJ2aWNlIiwiQ3VzdG9tZXJTZXJ2aWNlIiwiZ2V0QWxsQ3VzdG9tZXJzIiwicGFnaW5hdGlvbiIsImZpbHRlcnMiLCJwYXJhbXMiLCJnZXQiLCJlbmRwb2ludCIsImdldEN1c3RvbWVyQnlJZCIsImlkIiwiY3JlYXRlQ3VzdG9tZXIiLCJjdXN0b21lckRhdGEiLCJwb3N0IiwidXBkYXRlQ3VzdG9tZXIiLCJ1cGRhdGVEYXRhIiwicHV0IiwiZGVsZXRlQ3VzdG9tZXIiLCJkZWxldGUiLCJnZXRDdXN0b21lclN1bW1hcnkiLCJpbXBvcnRDdXN0b21lcnNGcm9tQ1NWIiwiZmlsZSIsIm9wdGlvbnMiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwic2tpcFZhbGlkYXRpb24iLCJjb250aW51ZU9uRXJyb3IiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImJhdGNoU2l6ZSIsInJlc3BvbnNlIiwiYXBpIiwiaGVhZGVycyIsInRpbWVvdXQiLCJkYXRhIiwiZXJyb3IiLCJnZXRJbXBvcnRTdGF0dXMiLCJpbXBvcnRJZCIsImNhbmNlbEltcG9ydCIsImdldEFjdGl2ZUltcG9ydHMiLCJjdXN0b21lclNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/customer.ts\n"));

/***/ })

});